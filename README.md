# App layers pokemonstore

> Пример гошного приложения в трёхслойной архитектуре "порты, юзкейсы и домены" со сквозными зависимостями

![image](assets/schema.svg)

- _Порты_ зависят от _юзкейсов_ и _доменов_
- _Юзкейсы_ зависят от _доменов_
- _Домены_ ни от чего не зависят (иногда друг от друга)

## Порты

Связь приложения (набора юзкейсов) с внешним миром. У одного приложения может быть множество разных портов - grpc, http, очереди, cli и т.д. В данном примере представлен один порт - grpc.

Порт это внешнее кольцо в архитектурном круге, его должно быть можно менять, не внося правки, в какие-либо нижележащие слои, потому **от него ничего не должно зависеть**.

**Порт не ходит в репозитории напрямую** - позже мы обсудим, что это значит. Вместо этого порт вызывает _юзкейсы_. Один порт может зависеть от нескольких юзкейсов, хотя это редкость и может означать, что хэндлер раздувается - в нём копится бизнес-логика.

В данном примере у каждого хэндлера отдельный пакет, но это не важно. Важнее, что у каждого хэндлера есть свой интерфейс для юзкейса (о них ниже). Это инверсия зависимости (IOC) - она позволяет написать на хэндлер юнит-тест, замокав нижележащие юзкейсы. Нужно ли покрывать порты юнит-тестами, отдельный вопрос. Если нет - можно завязать хэндлер напрямую на юзкейсы.

## Юзкейсы

Сценарии использования. Одно действие, которое совершает пользователь сервиса. В данном приложении есть только один юзкейс - купить покемона. Чтобы это сделать, юзкейс совершает вызовы к _репозиториям_ "аккаунтов" и "покемонов" и зависит от них.

Юзкейс это прослойка между портом и доменом. Это то самое место, где происходит бизнес-логика. Никакие правки в портах не должны приводить к правкам в юзкейсах (и доменах). Никакие правки в юзкейсах не должны приводить к правкам в доменах (но могут приводить к правкам в портах).

Юзкейс это оркестратор над репозиториями. Один юзкейс может зависеть от множества репозиториев, в том числе из разных доменов. Технически, это структура с полями-зависимостями (репозиториями) и одним методом (в данном случае `Handle`). Можно иметь сколько угодно подметодов, вызываемых из корневого `Handle`, если юзкейс сложный. А вот глубокой вложенности вызовов лучше избегать.

## Домены

Предметная область. В одном приложении может быть несколько предметных областей. Иногда они зависят друг от друга, но это редкость. Предметная область **это самая важная часть кода** - она должна быть максимально _устойчива_ к изменениям (домен ни от чего не зависит, всё зависит от домена). Главные вещи, живущие в домене это _сущности_ (типы данных) и _репозитории_.

### Репозитории

Интерфейс, определяющий работу с данными в каком-либо домене.

Репозиторий не должен иметь много методов и делать каких-то комплексных вещей. В идеале это CRUD-like набор операций. Любая комплексная логика должна быть в юзкейсе.

У репозитория может быть множество реализаций (например, моки для тестов), потому сама реализация лежит в отдельном пакете. **Реализация зависит от домена**, но никогда не наоборот.

Если сервис `A` ходит в сервис `B`, он обязательно должен делать это через интерфейс. Такой интерфейс - и есть репозиторий. Также он может ходить в базу данных или просто читать файлы с диска - не имеет значения. Суть в том, что мы обращаемся к внешнему компоненту, который можем подменить, не изменяя интерфейс.
